<?php

declare(strict_types=1);

namespace App\Libs\Cacheable;

use Illuminate\Support\Collection;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Pagination\Paginator;

/**
 * @mixin \Illuminate\Database\Query\Builder
 */
class EloquentBuilder extends Builder
{
    /**
     * Execute the query as a "select" statement.
     *
     * @param array $columns
     *
     * @return \Illuminate\Database\Eloquent\Collection|static[]
     */
    public function get($columns = ['*'])
    {
        $builder = $this->applyScopes();

        $closure = function () use ($builder, $columns) {
            // If we actually found models we will also eager load any relationships that
            // have been specified as needing to be eager loaded, which will solve the
            // n+1 query issue for the developers to avoid running a lot of queries.
            if (count($models = $builder->getModels($columns)) > 0) {
                $models = $builder->eagerLoadRelations($models);
            }

            return $builder->model->newCollection($models);
        };

        // Check if cache is enabled
        if ($builder->model->getCacheLifetime()) {
            return $builder->model->cacheQuery($builder, $columns, $closure);
        }

        // Cache disabled, just execute query & return result
        $results = call_user_func($closure);

        // We're done, let's clean up!
        $builder->model->resetCacheConfig();

        return $results;
    }

    /**
     * @inheritDoc
     */
    public function paginate($perPage = null, $columns = ['*'], $pageName = 'page', $page = null)
    {
        $page = $page ?: Paginator::resolveCurrentPage($pageName);

        $perPage = $perPage ?: $this->model->getPerPage();

        $results = ($total = $this->toBase()->getCountForPagination() && dump($this->toSql(), $this->getBindings()) )
            ? $this->forPage($page, $perPage)->get($columns)
            : $this->model->newCollection();

        return $this->paginator($results, $total, $perPage, $page, [
            'path' => Paginator::resolveCurrentPath(),
            'pageName' => $pageName,
        ]);

//        return parent::paginate($perPage, $columns, $pageName, $page); // TODO: Change the autogenerated stub
    }


    /**
     * @inheritDoc
     */
    protected function runPaginationCountQuery($columns = ['*'])
    {
        $results = $this->runPaginationCountQuery($columns);

        // Once we have run the pagination count query, we will get the resulting count and
        // take into account what type of query it was. When there is a group by we will
        // just return the count of the entire results set since that will be correct.
        if (isset($this->groups)) {
            return count($results);
        } elseif (! isset($results[0])) {
            return 0;
        } elseif (is_object($results[0])) {
            return (int) $results[0]->aggregate;
        }

        return (int) array_change_key_case((array) $results[0])['aggregate'];
//        return parent::runPaginationCountQuery($columns); // TODO: Change the autogenerated stub
    }


    /**
     * @inheritDoc
     */
    public function getCountForPagination($columns = ['*'])
    {
        return parent::getCountForPagination($columns); // TODO: Change the autogenerated stub
    }

    /**
     * Get an array with the values of a given column.
     *
     * @param string      $column
     * @param string|null $key
     *
     * @return \Illuminate\Support\Collection
     */
    public function pluck($column, $key = null): Collection
    {
        $builder = $this->toBase();

        $closure = function () use ($builder, $column, $key) {
            $results = $builder->pluck($column, $key);

            // If the model has a mutator for the requested column, we will spin through
            // the results and mutate the values so that the mutated version of these
            // columns are returned as you would expect from these Eloquent models.
            if (! $this->model->hasGetMutator($column) &&
                ! $this->model->hasCast($column) &&
                ! in_array($column, $this->model->getDates())) {
                return $results;
            }

            return $results->map(function ($value) use ($column) {
                return $this->model->newFromBuilder([$column => $value])->{$column};
            });
        };

        // Check if cache is enabled
        if ($this->model->getCacheLifetime()) {
            return $this->model->cacheQuery($builder, (array) $column, $closure);
        }

        // Cache disabled, just execute query & return result
        $results = call_user_func($closure);

        // We're done, let's clean up!
        $this->model->resetCacheConfig();

        return $results;
    }
}
